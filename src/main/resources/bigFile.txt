Общее Описание

Для начала немного общей теории. Вспомним, в общих чертах, как работает Garbage Collector (далее GC).
Если не вдаваться в детали, то алгоритм прост: при запуске сборщика виртуальная машина рекурсивно находит,
для всех потоков, все доступные объекты в памяти и помечает их неким образом. А на следующем шаге GC удаляет
из памяти все непомеченные объекты. Таким образом, после чистки, в памяти будут находиться только те объекты,
которые могут быть полезны программе. Идем дальше.
В Java есть несколько видов ссылок. Есть StrongReference — это самые обычные ссылки которые мы создаем каждый день.
	StringBuilder builder = new StringBuilder();
builder это и есть strong-ссылка на объект StringBuilder.
И есть 3 «особых» типа ссылок — SoftReference, WeakReference, PhantomReference. По сути, различие между всеми
типами ссылок только одно — поведение GC с объектами, на которые они ссылаются. Мы более детально обсудим
особенности каждого типа ссылок позже, а пока достаточно будет следующих знаний:
SoftReference — если GC видит что объект доступен только через цепочку soft-ссылок, то он удалит его из памяти.
Потом. Наверно.
WeakReference — если GC видит что объект доступен только через цепочку weak-ссылок, то он удалит его из памяти.
PhantomReference — если GC видит что объект доступен только через цепочку phantom-ссылок, то он его удалит из
памяти. После нескольких запусков GC.
Если пока не понятно в чем же разница, то не переживайте, скоро все станет на свои места. Мелочи в деталях, а
детали будут дальше.
Эти 3 типа ссылок наследуются от одного родителя — Reference, у которого они собственно и берут все свои
public методы и конструкторы.

    StringBuilder builder = new StringBuilder();
    SoftReference<StringBuilder> softBuilder = new SoftReference(builder);

После выполнения этих двух строчек у нас будет 2 типа ссылок на 1 объект StringBuilder:
builder — strong-ссылка
softBuilder — soft-ссылка (формально это strong-ссылка на soft-ссылку, но для простоты я буду писать soft-ссылка)
И если во время выполнения программы, переменная builder станет недоступной, но при этом ссылка на объект, на
который ссылается softBuilder, будет еще доступна И запустится GC -> то объект StringBuilder будет помечен как
доступный только через цепочку soft-ссылок.
Рассмотрим доступные методы:
softBuilder.get() — вернет strong-ссылку на объект StringBuilder в случае если GC не удалил этот объект из памяти.
В другом случае вернется null.
softBuilder.clear() — удалит ссылку на объект StringBuilder (то есть soft-ссылки на этот объект больше нет)
Все то же самое работает и для WeakReference и для PhantomReference. Правда, PhantomReference.get() всегда будет
возвращать null, но об этом позже.
Есть еще такой класс – ReferenceQueue. Он позволяет отслеживать момент, когда GC определит что объект более не нужен
и его можно удалить. Именно сюда попадает Reference объект после того как объект на который он ссылается удален
из памяти. При создании Reference мы можем передать в конструктор ReferenceQueue, в который будут помещаться
ссылки после удаления.